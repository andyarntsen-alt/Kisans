import type { Guide } from './types';

export const byggAiAgent: Guide = {
    slug: 'bygg-ai-agent',
    tag: 'GUIDE \u00B7 AI-AGENTER',
    title: 'Bygg din egen AI-agent',
    description: 'Lær å bygge din egen AI-agent steg for steg. Fra ReAct-mønsteret og verktøybruk til praktiske eksempler med Vercel AI SDK og Anthropic Claude. Komplett guide til agentutvikling på norsk.',
    keywords: ['bygg ai agent', 'ai agent', 'ai agent guide', 'tool calling', 'react agent', 'ai agent norsk'],
    publishedDate: '2026-02-10',
    relatedSlugs: ['ai-agenter', 'bygg-ai-chatbot', 'openai-api'],
    category: 'bygg-med-ai',
    sections: [
        {
            heading: 'Hva er en AI-agent?',
            content: 'En chatbot svarer på spørsmål. En AI-agent løser oppgaver. Det høres kanskje ut som en liten forskjell, men i praksis er det et fundamentalt skille. Når du ber en chatbot om å finne billige flybilletter til Barcelona, får du en generell tekst om hvordan du kan søke etter flyreiser. Når du ber en AI-agent om det samme, søker den faktisk gjennom flysøk-APIer, sammenligner priser, filtrerer på datoene dine og presenterer konkrete alternativer. Agenten handler på vegne av deg.\n\nDet som gjør en agent til en agent er tre egenskaper: resonnering, verktøybruk og autonomi. Resonnering betyr at agenten kan bryte ned en kompleks oppgave i mindre steg og planlegge hvordan den skal løse dem. Verktøybruk betyr at den kan kalle eksterne funksjoner, APIer og systemer for å hente informasjon eller utføre handlinger. Autonomi betyr at den kan jobbe gjennom flere steg på egen hånd, evaluere resultatene underveis og justere tilnærmingen hvis noe ikke fungerer som forventet.\n\nI 2026 ser vi AI-agenter overalt. Claude Code og Codex skriver og redigerer kode på tvers av hele kodebaser. Kundeserviceagenter løser henvendelser uten menneskelig innblanding. Forskningsagenter søker gjennom hundrevis av kilder og lager oppsummeringer. Forskjellen fra et år siden er at verktøyene for å bygge egne agenter har blitt drastisk enklere. Du trenger ikke lenger et rammeverk med tusenvis av linjer kode. Med Vercel AI SDK eller Anthropic Claude sitt API kan du bygge en fungerende agent på under hundre linjer.'
        },
        {
            heading: 'Arkitektur: ReAct, verktøy og minne',
            content: 'Det mest brukte mønsteret for AI-agenter heter ReAct, som står for Reasoning and Acting. Ideen er enkel: modellen tenker først (reasoning), deretter handler (acting), observerer resultatet, og gjentar denne syklusen til oppgaven er løst. I praksis ser det slik ut: agenten mottar en oppgave, resonnerer over hva den trenger å gjøre, velger et verktøy å bruke, får resultatet tilbake, resonnerer over hva resultatet betyr, og bestemmer om den er ferdig eller trenger å gjøre mer.\n\nVerktøy er hjertet av en agent. Et verktøy er i bunn og grunn en funksjon som agenten kan kalle, beskrevet med et navn, en forklaring av hva det gjør, og et skjema for hvilke parametere det tar. For eksempel kan et søkeverktøy ha navnet search med parameteren query av typen string. Når AI-modellen bestemmer seg for å bruke verktøyet, genererer den et strukturert kall med de riktige parameterne. Din kode kjører funksjonen og sender resultatet tilbake til modellen. Anthropic kaller dette tool use, OpenAI kaller det function calling, og Vercel AI SDK har en unified tool-abstraksjon som fungerer på tvers av leverandører.\n\nMinne er det tredje viktige elementet. Uten minne glemmer agenten alt mellom hver melding. Korttidsminne er samtalehistorikken, altså de tidligere meldingene i dialogen. Langtidsminne kan være en database der agenten lagrer viktig informasjon den har lært, slik at den kan hente det frem i fremtidige samtaler. For mange agenter er korttidsminne nok, men for agenter som skal jobbe over lengre perioder eller huske brukerpreferanser er langtidsminne avgjørende.\n\nAnthropics forskningsartikkel Building Effective Agents fra desember 2024 beskriver flere arkitekturer utover enkle agentløkker. Prompt chaining kjeder flere LLM-kall etter hverandre der output fra ett steg blir input til neste. Routing sender forespørselen til ulike behandlingsveier basert på type. Parallelisering lar flere LLM-kall kjøre samtidig og kombinerer resultatene. Evaluator-optimizer-mønsteret bruker en LLM til å evaluere output fra en annen og gi tilbakemelding for forbedring. Disse mønstrene kan kombineres for å bygge sofistikerte systemer.'
        },
        {
            heading: 'Bygge med Vercel AI SDK',
            content: 'Vercel AI SDK er det mest populære open source-biblioteket for å bygge AI-applikasjoner med TypeScript, og det har førsteklasses støtte for agenter gjennom tool calling og maxSteps. Dokumentasjonen finner du på ai-sdk.dev. For å komme i gang installerer du ai-pakken sammen med en leverandørpakke: npm install ai @ai-sdk/anthropic eller npm install ai @ai-sdk/openai.\n\nVerktøydefinisjon i Vercel AI SDK bruker tool-funksjonen fra ai-pakken. Du gir verktøyet et navn, en description som forklarer modellen når den skal bruke det, et parameters-objekt definert med Zod-skjemaer for typevalidering, og en execute-funksjon som kjører den faktiske logikken. For eksempel kan du definere et verktøy som søker på nettet ved å gi det parameteren query av typen z.string(), og en execute-funksjon som kaller et søke-API og returnerer resultatene.\n\nNøkkelen til agentisk oppførsel er maxSteps-parameteren i generateText eller streamText. Denne forteller SDK-en hvor mange ganger modellen får lov til å kalle verktøy i sekvens før den må gi et endelig svar. Hvis du setter maxSteps til 5, kan agenten resonere, kalle et verktøy, få resultatet, kalle et annet verktøy, få det resultatet, og så formulere svaret. Uten maxSteps stopper modellen etter første verktøykall. Med maxSteps får du en ekte agent som kan jobbe seg gjennom flere steg autonomt.\n\nEn typisk agentflyt i Next.js ser slik ut: du oppretter en API-rute som bruker streamText med en modell, et system-prompt, en meldingsarray, et sett med verktøy, og maxSteps satt til for eksempel 10. På klientsiden bruker du useChat-hooken som håndterer strømming og verktøykall automatisk. Brukeren ser agentens tankeprosess og resultater i sanntid. Vercel AI SDK håndterer hele løkken mellom modell og verktøy uten at du trenger å skrive den logikken selv.'
        },
        {
            heading: 'Bygge med Anthropic Claude tool use',
            content: 'Anthropic Claude sitt API har innebygd støtte for verktøybruk gjennom tool use-funksjonaliteten. Du finner dokumentasjonen på docs.anthropic.com/en/docs/build-with-claude/tool-use. Tilnærmingen er litt mer manuell enn Vercel AI SDK, men gir deg full kontroll over agentløkken og er et godt alternativ hvis du vil forstå nøyaktig hva som skjer under panseret.\n\nNår du sender en forespørsel til Claude API med verktøy definert, inkluderer du en tools-array der hvert verktøy har et name, en description og et input_schema definert som JSON Schema. Modellen svarer med en respons som enten inneholder vanlig tekst i content-arrayen, eller et tool_use-objekt med verktøyets navn og de genererte parameterne. Hvis modellen vil bruke et verktøy, setter den stop_reason til tool_use. Din kode fanger opp dette, kjører den aktuelle funksjonen, og sender resultatet tilbake som en tool_result-melding. Denne frem-og-tilbake-dialogen fortsetter til modellen er ferdig og gir et tekstsvar.\n\nFor å bygge en agent med Claude API skriver du en løkke som fortsetter så lenge modellen returnerer tool_use som stop_reason. I hvert steg tar du verktøykallet fra svaret, kjører den tilsvarende funksjonen i koden din, og legger til både modellens svar og verktøyresultatet i meldingshistorikken før du sender neste forespørsel. Det er i praksis en while-løkke der du bygger opp samtalehistorikken steg for steg. Husk å sette en maks-grense på antall iterasjoner for å unngå uendelige løkker.\n\nClaude er spesielt sterk på kompleks resonnering og følger verktøyinstruksjoner nøyaktig. Modellen er god til å velge riktig verktøy i situasjoner der flere er tilgjengelige, og den formulerer parametere presist basert på konteksten. For produksjonsapplikasjoner tilbyr Anthropic også extended thinking som lar modellen vise resonneringsprosessen sin eksplisitt, noe som er nyttig for debugging og for å bygge tillit til agentens beslutninger.'
        },
        {
            heading: 'Eksempel: Research-agent som søker og oppsummerer',
            content: 'La oss bygge en konkret agent: en research-agent som tar et tema, søker etter informasjon fra flere kilder, og lager en strukturert oppsummering. Dette er en av de mest nyttige agenttypene og illustrerer kjernekonseptene godt. Vi bruker Vercel AI SDK med Claude som modell, men mønsteret fungerer med enhver leverandør.\n\nAgenten trenger tre verktøy. Det første er et søkeverktøy som tar en søkestreng og returnerer en liste med resultater fra et søke-API som Tavily, Brave Search API eller SerpAPI. Det andre er et hent-innhold-verktøy som tar en URL og returnerer tekstinnholdet fra den siden. Det tredje er et notat-verktøy som lar agenten lagre viktige funn underveis, slik at den kan referere til dem når den skriver oppsummeringen. System-promptet instruerer agenten til å søke bredt først, deretter lese de mest relevante kildene, ta notater om nøkkelfunn, og til slutt skrive en helhetlig oppsummering med referanser.\n\nNår brukeren skriver for eksempel «Hva er status for kvantecomputing i 2026?», starter agenten med å kalle søkeverktøyet med flere ulike søkestrenger for å dekke temaet bredt. Den leser gjennom de mest lovende resultatene med hent-innhold-verktøyet, tar notater om viktige funn, og bygger gradvis opp en forståelse av temaet. Hele prosessen kan ta fem til ti verktøykall, og med maxSteps satt til 15 har agenten god plass til å jobbe grundig.\n\nDet ferdige resultatet er en oppsummering som er basert på faktiske kilder, ikke bare modellens treningsdata. Brukeren får både oppsummeringen og en liste over kildene agenten brukte. Dette mønsteret kan utvides på mange måter: du kan legge til et verktøy for å lagre resultater i en database, et verktøy for å sende oppsummeringen på e-post, eller et verktøy for å generere en PDF-rapport. Det er her kraften i agenter virkelig viser seg, du bygger modulære evner som agenten kombinerer etter behov.'
        },
        {
            heading: 'Testing, guardrails og feilhåndtering',
            content: 'AI-agenter er ikke-deterministiske. Det betyr at samme input kan gi forskjellig output hver gang. Dette gjør testing annerledes enn for vanlig programvare. Du kan ikke bare sjekke om output er nøyaktig lik forventet verdi. I stedet tester du adferd: Kalte agenten riktig verktøy? Fikk den et gyldig resultat? Var det endelige svaret relevant og basert på verktøyresultatene? Skriv tester som sjekker disse egenskapene med assertions som er fleksible nok til å håndtere variasjon i formuleringer.\n\nGuardrails er sikkerhetstiltak som forhindrer at agenten gjør noe den ikke skal. Den viktigste guardrail-en er å begrense hvilke verktøy agenten har tilgang til. En agent som bare har et søkeverktøy og et notatverktøy kan ikke sende e-poster eller slette filer, uansett hva brukeren ber om. Sett alltid en maksgrense på antall steg agenten kan ta for å unngå uendelige løkker. Valider alle parametere fra modellen før du kjører et verktøy, spesielt hvis verktøyet gjør noe destruktivt. Og legg inn menneskelig godkjenning for handlinger med høy risiko, som å sende meldinger, endre data eller utføre betalinger.\n\nFeilhåndtering i agenter krever ekstra omtanke. Hva skjer når et verktøy feiler? Den enkleste strategien er å returnere en feilmelding til modellen i stedet for å krasje. Modellen kan da prøve en annen tilnærming, prøve på nytt, eller informere brukeren om at den ikke klarte oppgaven. Logg alle verktøykall, parametere og resultater slik at du kan feilsøke og forbedre agenten over tid. Sett opp overvåkning av kostnader og tokenbruk, siden en agent som tar mange steg kan bruke betydelig flere tokens enn en enkel chatbot.\n\nFor produksjonsklare agenter bør du også vurdere rammeverk som gir deg struktur for mer komplekse oppsett. LangChain tilbyr LangGraph for å bygge agenter som tilstandsmaskiner med definerte overganger mellom steg. CrewAI lar deg definere flere agenter med ulike roller som samarbeider om en oppgave. Mastra er et nyere TypeScript-rammeverk som gir deg agenter, verktøy og arbeidsflyter i en samlet pakke. For mange bruksområder er Vercel AI SDK med noen egne hjelpefunksjoner mer enn nok, men når agenten din vokser i kompleksitet kan et dedikert rammeverk spare deg for mye arbeid.'
        }
    ]
};
